<!doctype html>
<html xml:lang="zh-CN" lang="zh-CN">

<head>
        <link rel="canonical" href="https://hysteriawindows.github.io/news/article-85505.htm" />
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>深入理解mmap&#8211;内核代码分析及驱动demo示例</title>
        <meta name="description" content="mmap是一个很常用的系统调用，无论是分配内存、读写大文件、链接动态库文件，还是多进程间共享内存，都可以看到其身影。本文首先介绍了进程地址空间和mmap，然后分析了内核代码以了解其实现，最后通过一个简" />
        <link rel="icon" href="/assets/website/img/hysteriawindows/favicon.ico" type="image/x-icon"/>

    <meta name="author" content="HysteriaWindows免费节点官网">
    <meta property="og:type" content="article" />
    <meta property="og:url" content="https://hysteriawindows.github.io/news/article-85505.htm" />
    <meta property="og:site_name" content="HysteriaWindows免费节点官网" />
    <meta property="og:title" content="深入理解mmap&#8211;内核代码分析及驱动demo示例" />
    <meta property="og:image" content="https://hysteriawindows.github.io/uploads/20240814/0b5262547d522c3091ac6c80630214e1.webp" />
        <meta property="og:release_date" content="2025-03-31T08:42:18" />
    <meta property="og:updated_time" content="2025-03-31T08:42:18" />
        <meta property="og:description" content="mmap是一个很常用的系统调用，无论是分配内存、读写大文件、链接动态库文件，还是多进程间共享内存，都可以看到其身影。本文首先介绍了进程地址空间和mmap，然后分析了内核代码以了解其实现，最后通过一个简" />
    
    <meta name="applicable-device" content="pc,mobile" />
    <meta name="renderer" content="webkit" />
    <meta name="force-rendering" content="webkit" />
    <meta http-equiv="Cache-Control" content="no-transform" />
    <meta name="robots" content="max-image-preview:large" />
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="apple-mobile-web-app-title" content="深入理解mmap&#8211;内核代码分析及驱动demo示例">
    <meta name="format-detection" content="telephone=no">

    <link rel="dns-prefetch" href="https:/www.googletagmanager.com">
    <link rel="dns-prefetch" href="https://www.googleadservices.com">
    <link rel="dns-prefetch" href="https://www.google-analytics.com">
    <link rel="dns-prefetch" href="https://pagead2.googlesyndication.com">
    <link rel="dns-prefetch" href="https://cm.g.doubleclick.net">
        
    <!-- Bootstrap CSS -->
    <link rel="stylesheet" href="/assets/website/css/hysteriawindows/bootstrap.css">
    <link rel="stylesheet" href="/assets/website/css/hysteriawindows/themify-icons.css">
    <link rel="stylesheet" href="/assets/website/js/frontend/hysteriawindows/fontawesome/css/all.min.css">
    <link rel="stylesheet" href="/assets/website/js/frontend/hysteriawindows/owl-carousel/owl.carousel.min.css">
    <link rel="stylesheet" href="/assets/website/js/frontend/hysteriawindows/animate-css/animate.css">
    <!-- main css -->
    <link rel="stylesheet" href="/assets/website/css/hysteriawindows/style.css">
    <link rel="stylesheet" href="/assets/website/css/hysteriawindows/responsive.css">
    <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-W3GH5FWSVJ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-W3GH5FWSVJ');
</script>
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3332997411212854"
     crossorigin="anonymous"></script>
</head>

<body data-page="detail">
        <!--================Header Menu Area =================-->
    <header class="header_area">
        <div class="main_menu">
            <nav class="navbar navbar-expand-lg navbar-light">
                <div class="container">
                    <!-- Brand and toggle get grouped for better mobile display -->
                    <a class="navbar-brand logo_h" href="/">
                                        <span>Hysteria Windows</span>
                                        </a>
                    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>
                    <!-- Collect the nav links, forms, and other content for toggling -->
                    <div class="collapse navbar-collapse offset" id="navbarSupportedContent">
                        <ul class="nav navbar-nav menu_nav ml-auto">
                                                        <li class="nav-item"><a class="nav-link" href="/">首页</a></li>
                                                        <li class="nav-item"><a class="nav-link" href="/free-nodes/">免费节点</a></li>
                                                        <li class="nav-item"><a class="nav-link" href="/paid-subscribe/">推荐机场</a></li>
                                                        <li class="nav-item"><a class="nav-link" href="/client.htm">客户端</a></li>
                                                        <li class="nav-item"><a class="nav-link" href="/news/">新闻资讯</a></li>
                                                    </ul>
                    </div>
                </div>
            </nav>
        </div>
    </header>
    <!--================Header Menu Area =================-->
    <!--================Hero Banner Area Start =================-->
    <section class="hero-banner d-flex align-items-center">
        <div class="container text-center">
            <h1>深入理解mmap&#8211;内核代码分析及驱动demo示例</h1>
            <nav aria-label="breadcrumb" class="banner-breadcrumb">
                <ol class="breadcrumb">
                    <li class="breadcrumb-item"><a href="/">首页</a></li>
                    <li class="breadcrumb-item"><a href="/news/">新闻资讯</a></li>
                    <li class="breadcrumb-item active" aria-current="page">正文</li>
                </ol>
            </nav>
        </div>
    </section>
    <!--================Hero Banner Area End =================-->
    <!--================About  Area =================-->
    <section class="statics-area area-padding">
        <div class="container">
            <div class="row">
                <div class="col-md-9">
                                    <input type="hidden" id="share-website-info" data-name="" data-url="">
                  				  				  				<p>mmap是一个很常用的系统调用，无论是分配内存、读写大文件、链接动态库文件，还是多进程间共享内存，都可以看到其身影。本文首先介绍了进程地址空间和mmap，然后分析了内核代码以了解其实现，最后通过一个简单的demo驱动示例，加深对mmap的理解。</p> <p>本博客已迁移至<a href="http://www.m6000.cn/wp-content/themes/begin%20lts/inc/go.php?url=https://catbro666.github.io/"  target="_blank" rel="nofollow">CatBro's Blog</a>，那是我自己搭建的个人博客，欢迎关注。</p> <p><a href="http://www.m6000.cn/wp-content/themes/begin%20lts/inc/go.php?url=https://catbro666.github.io/posts/5ec4fb12/"  target="_blank" rel="nofollow">本文链接</a></p> <h2 id="进程地址空间及vma">进程地址空间及vma</h2> <p>作为前置知识，先来对进程地址空间做个简单介绍，以便更好地理解后面的内容。现代操作系统的内存管理离不开硬件的支持，如分段机制、分页机制。它们用于实现内存的隔离、保护以及高效使用。进程之间地址空间相互隔离，每个进程都有一套页表，实现线性地址到物理地址的转换。</p> <h3 id="虚拟内存映射">虚拟内存映射</h3> <p>下面是32位系统（x86）的进程地址空间布局图</p> <p><img decoding="async" src="http://img.555519.xyz/uploads3/20220509/2699b70af243f6b98d823f68e5681ffd.jpg" alt="深入理解mmap--内核代码分析及驱动demo示例"></p> <p>0～3G 部分是用户空间的地址，3G～4G 部分是内核地址空间。虚拟地址从低到高分别为代码段、数据段（已初始化的静态变量）、bss段（未初始化的静态变量）、heap堆、mmap映射区、栈、命令行参数、环境变量。</p> <p>从0xc0000000开始就是内核地址空间了。内核地址空间又分为线性内存区和高端内存区。高端内存区是用于vmalloc机制、fixmap等的。在x86体系中，最低16MB物理内存是DMA内存区，用于执行DMA操作。</p> <p>64位系统（x86_64）上，内存地址可用空间为0x0000000000000000 ~ 0xFFFFFFFFFFFFFFFF，这是一个非常巨大的地址空间。而Linux实际上只用了低47位（128T），高17位作扩展。实际用到的地址空间为<strong>0x0000000000000000 ~ 0x00007FFFFFFFFFFF</strong>（用户空间）和<strong>0xFFFF800000000000 ~ 0xFFFFFFFFFFFFFFFF</strong>（内核空间）。</p> <p>在64位处理器中，由于有足够的内核空间可以线性映射物理内存，所以就不需要高端内存这个管理区了。更详细的信息可以参考<a href="http://www.m6000.cn/wp-content/themes/begin%20lts/inc/go.php?url=https://www.kernel.org/doc/Documentation/x86/x86_64/mm.txt"  target="_blank" rel="nofollow">内核文档</a>。</p> <h3 id="vma">VMA</h3> <p>进程地址空间在Linux内核中使用<code>struct vm_area_struct</code>来描述，简称<strong>VMA</strong>。由于这些地址空间归属于各个用户进程，所以在用户进程的<code>struct mm_struct</code>中也有相应的成员。进程可以通过内核的内存管理机制动态地添加或删除这些内存区域。</p> <p>每个内存区域具有相关的权限，比如可读、可写、可执行。如果进程访问了不在有效范围内的内存区域、或非法访问了内存，那么处理器会报缺页异常，严重的会出现段错误。</p> <pre><code class="language-c">// include/linux/mm_types.h  /*  * This struct defines a memory VMM memory area. There is one of these  * per VM-area/task.  A VM area is any part of the process virtual memory  * space that has a special rule for the page-fault handlers (ie a shared  * library, the executable area etc).  */ struct vm_area_struct {     /* The first cache line has the info for VMA tree walking. */      unsigned long vm_start;     /* Our start address within vm_mm. */     unsigned long vm_end;       /* The first byte after our end address                        within vm_mm. */      /* linked list of VM areas per task, sorted by address */     struct vm_area_struct *vm_next, *vm_prev;      struct rb_node vm_rb;      /*      * Largest free memory gap in bytes to the left of this VMA.      * Either between this VMA and vma-&gt;vm_prev, or between one of the      * VMAs below us in the VMA rbtree and its -&gt;vm_prev. This helps      * get_unmapped_area find a free area of the right size.      */     unsigned long rb_subtree_gap;      /* Second cache line starts here. */      struct mm_struct *vm_mm;    /* The address space we belong to. */     pgprot_t vm_page_prot;      /* Access permissions of this VMA. */     unsigned long vm_flags;     /* Flags, see mm.h. */      /*      * For areas with an address space and backing store,      * linkage into the address_space-&gt;i_mmap interval tree.      */     struct {         struct rb_node rb;         unsigned long rb_subtree_last;     } shared;      /*      * A file's MAP_PRIVATE vma can be in both i_mmap tree and anon_vma      * list, after a COW of one of the file pages.  A MAP_SHARED vma      * can only be in the i_mmap tree.  An anonymous MAP_PRIVATE, stack      * or brk vma (with NULL file) can only be in an anon_vma list.      */     struct list_head anon_vma_chain; /* Serialized by mmap_sem &amp;                       * page_table_lock */     struct anon_vma *anon_vma;  /* Serialized by page_table_lock */      /* Function pointers to deal with this struct. */     const struct vm_operations_struct *vm_ops;      /* Information about our backing store: */     unsigned long vm_pgoff;     /* Offset (within vm_file) in PAGE_SIZE                        units */     struct file * vm_file;      /* File we map to (can be NULL). */     void * vm_private_data;     /* was vm_pte (shared mem) */      atomic_long_t swap_readahead_info; #ifndef CONFIG_MMU     struct vm_region *vm_region;    /* NOMMU mapping region */ #endif #ifdef CONFIG_NUMA     struct mempolicy *vm_policy;    /* NUMA policy for the VMA */ #endif     struct vm_userfaultfd_ctx vm_userfaultfd_ctx; } __randomize_layout;</code></pre> <p>解释下几个主要的成员：</p> <ul> <li>vm_start和vm_end：表示vma的起始和结束地址，相减就是vma的长度</li> <li>vm_next和vm_prev：链表指针</li> <li>vm_rb：红黑树节点</li> <li>vm_mm：所属进程的内存描述符mm_struct数据结构</li> <li>vm_page_prot：vma的访问权限</li> <li>vm_flags：vma的标志</li> <li>anon_vma_chain和anon_vma：用于管理RMAP反向映射</li> <li>vm_ops：指向操作方法结构体</li> <li>vm_pgoff：文件映射的偏移量。</li> <li>vm_file：指向被映射的文件</li> </ul> <h2 id="mmap简介">mmap简介</h2> <pre><code class="language-c">// include&lt;sys/mman.h&gt; void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset); int munmap(void *addr, size_t length);</code></pre> <ul> <li>addr：指定起始地址，为了可移植性一般设为NULL</li> <li>length：表示映射到进程地址空间的大小</li> <li>prot：读写属性，PROT_EXEC、PROT_READ、PROT_WRITE、PROT_NONE</li> <li>flags：标志，如共享映射、私有映射</li> <li>fd：文件描述符，匿名映射时设为-1。</li> <li>offset：文件映射时，表示偏移量</li> </ul> <h3 id="flag标志">flag标志</h3> <ul> <li>MAP_SHARED：创建一个共享的映射区域。多个进程可以这样映射同一个文件，修改后的内容会同步到磁盘文件中。</li> <li>MAP_PRIVATE：创建写时复制的私有映射。多个进程可以私有映射同一个文件，修改之后不会同步到磁盘中。</li> <li>MAP_ANONYMOUS：创建匿名映射，即没有关联到文件的映射</li> <li>MAP_FIXED：使用参数addr创建映射，如果无法映射指定的地址就返回失败，addr要求按页对齐。如果指定的地址空间与已有的VMA重叠，会先销毁重叠的区域。</li> <li>MAP_POPULATE：对于文件映射，会提前预读文件内容到映射区域，该特性只支持私有映射。</li> </ul> <h3 id="4类映射">4类映射</h3> <p>根据prot和flags的不同组合，可以分为以下4种映射类型：</p> <ul> <li>私有匿名：通常用于内存分配（大块）</li> <li>私有文件：通常用于加载动态库</li> <li>共享匿名：通常用于进程间共享内存，默认打开<code>/dev/zero</code>这个特殊的设备文件</li> <li>共享文件：通常用于内存映射I/O，进程间通信</li> </ul> <h3 id="mmap内存映射原理">mmap内存映射原理</h3> <ol> <li>当用户空间调用mmap时，系统会寻找一段满足要求的连续虚拟地址，然后创建一个新的vma插入到mm系统的链表和红黑树中。</li> <li>调用内核空间mmap，建立文件块/设备物理地址和进程虚拟地址vma的映射关系 <ol> <li>如果是磁盘文件，没有特别设置标志的话这里只是建立映射不会实际分配内存。</li> <li>如果是设备文件，直接通过remap_pfn_range函数建立设备物理地址到虚拟地址的映射。</li> </ol> </li> <li>（如果是磁盘文件映射）当进程对这片映射地址空间进行访问时，引发缺页异常，将数据从磁盘中拷贝到物理内存。后续用户空间就可以直接对这块内核空间的物理内存进行读写，省去了用户空间跟内核空间之间的拷贝过程。</li> </ol> <h2 id="内核代码分析">内核代码分析</h2> <p>当我们在用户空间调用mmap时，首先通过系统调用进入内核空间，可以看到这里将offset转成了以页为单位。</p> <pre><code class="language-c">// arch/x86/kernel/sys_x86_64.c SYSCALL_DEFINE6(mmap, unsigned long, addr, unsigned long, len,         unsigned long, prot, unsigned long, flags,         unsigned long, fd, unsigned long, off) {     long error;     error = -EINVAL;     if (off &amp; ~PAGE_MASK)         goto out;      error = sys_mmap_pgoff(addr, len, prot, flags, fd, off &gt;&gt; PAGE_SHIFT); out:     return error; }</code></pre> <p>来看系统调用<code>sys_mmap_pgoff</code>，如果是不是匿名映射，会通过fd获取file结构体。</p> <pre><code class="language-c">// mm/mmap.c SYSCALL_DEFINE6(mmap_pgoff, unsigned long, addr, unsigned long, len,         unsigned long, prot, unsigned long, flags,         unsigned long, fd, unsigned long, pgoff) {     struct file *file = NULL;     unsigned long retval;     if (!(flags &amp; MAP_ANONYMOUS)) {         // ...         file = fget(fd);         // ...     }     // ...     retval = vm_mmap_pgoff(file, addr, len, prot, flags, pgoff);     return retval; }</code></pre> <p>接着看<code>vm_mmap_pgoff</code>函数，这里主要用信号量对进程地址空间做了一个保护，然后根据populate的值会prefault页表，如果是文件映射则会对文件进行预读。</p> <pre><code class="language-c">// mm/util.c unsigned long vm_mmap_pgoff(struct file *file, unsigned long addr,     unsigned long len, unsigned long prot,     unsigned long flag, unsigned long pgoff) {     unsigned long ret;     struct mm_struct *mm = current-&gt;mm;     unsigned long populate;     LIST_HEAD(uf);      ret = security_mmap_file(file, prot, flag);     if (!ret) {         if (down_write_killable(&amp;mm-&gt;mmap_sem))             return -EINTR;         ret = do_mmap_pgoff(file, addr, len, prot, flag, pgoff,                     &amp;populate, &amp;uf);         up_write(&amp;mm-&gt;mmap_sem);         userfaultfd_unmap_complete(mm, &amp;uf);         if (populate)             mm_populate(ret, populate);     }     return ret; }</code></pre> <p><code>do_mmap_pgoff</code>只是简单调用<code>do_mmap</code></p> <pre><code class="language-c">// include/linux/mm.h static inline unsigned long do_mmap_pgoff(struct file *file, unsigned long addr,     unsigned long len, unsigned long prot, unsigned long flags,     unsigned long pgoff, unsigned long *populate,     struct list_head *uf) {     return do_mmap(file, addr, len, prot, flags, 0, pgoff, populate, uf); }</code></pre> <p>我们来看<code>do_mmap</code>实现：</p> <pre><code class="language-c">// mm/mmap.c unsigned long do_mmap(struct file *file, unsigned long addr,             unsigned long len, unsigned long prot,             unsigned long flags, vm_flags_t vm_flags,             unsigned long pgoff, unsigned long *populate,             struct list_head *uf) {     struct mm_struct *mm = current-&gt;mm;     // ...     len = PAGE_ALIGN(len);     // ...     addr = get_unmapped_area(file, addr, len, pgoff, flags);     // ...     addr = mmap_region(file, addr, len, vm_flags, pgoff, uf);     if (!IS_ERR_VALUE(addr) &amp;&amp;         ((vm_flags &amp; VM_LOCKED) ||          (flags &amp; (MAP_POPULATE | MAP_NONBLOCK)) == MAP_POPULATE))         *populate = len;     return addr; }</code></pre> <p>这个函数主要将映射长度页对齐，对prot属性和flags标志进行了检查和处理，设置了vm_flags。<code>get_unmapped_area</code>函数检查指定的地址或自动选择可用的虚拟地址。然后就调用<code>mmap_region</code>，可以看到返回之后，根据调用接口时设置的flags对populate进行了设置。如果设置了<code>MAP_LOCKED</code>，或者设置了<code>MAP_POPULATE</code>但没有设置<code>MAP_NONBLOCK</code>，就进行前面提到的prefault操作。</p> <p>然后继续看<code>mmap_region</code></p> <pre><code class="language-c">// mm/mmap.c unsigned long mmap_region(struct file *file, unsigned long addr,         unsigned long len, vm_flags_t vm_flags, unsigned long pgoff,         struct list_head *uf) {     // ...     vma = vma_merge(mm, prev, addr, addr + len, vm_flags,             NULL, file, pgoff, NULL, NULL_VM_UFFD_CTX);     if (vma)    // 可以跟之前的映射合并         goto out;          vma = kmem_cache_zalloc(vm_area_cachep, GFP_KERNEL);     vma-&gt;vm_mm = mm;     vma-&gt;vm_start = addr;     vma-&gt;vm_end = addr + len;     vma-&gt;vm_flags = vm_flags;     vma-&gt;vm_page_prot = vm_get_page_prot(vm_flags);     vma-&gt;vm_pgoff = pgoff;     INIT_LIST_HEAD(&amp;vma-&gt;anon_vma_chain);          if (file) {         // ...         vma-&gt;vm_file = get_file(file);         error = call_mmap(file, vma);   // 调用文件的mmap         //...     } else if (vm_flags &amp; VM_SHARED) {         error = shmem_zero_setup(vma);     }          // ...     return addr;     // ... }</code></pre> <p>该函数首先做了一些地址空间检查，接着<code>vma_merge</code>检查是否可以和老的映射合并，然后就是分配vma并初始化。如果是文件映射，调用<code>call_mmap</code>；如果是匿名共享映射，调用<code>shmem_zero_setup</code>，它里面会进行<code>/dev/zero</code>文件相关设置。</p> <p><code>call_mmap</code>只是简单地调用文件句柄中的mmap操作函数。</p> <pre><code class="language-c">// include/linux/fs.h static inline int call_mmap(struct file *file, struct vm_area_struct *vma) {     return file-&gt;f_op-&gt;mmap(file, vma); }</code></pre> <p>如果是普通文件系统中的文件的话，我们以ext4为例，里面主要是设置了<code>vma-&gt;vm_ops</code>为<code>ext4_file_vm_ops</code>。</p> <pre><code class="language-c">// fs/ext4/file.c static int ext4_file_mmap(struct file *file, struct vm_area_struct *vma) {     //...     vma-&gt;vm_ops = &amp;ext4_file_vm_ops;     //...     return 0; }  static const struct vm_operations_struct ext4_file_vm_ops = {     .fault      = ext4_filemap_fault,     .map_pages  = filemap_map_pages,     .page_mkwrite   = ext4_page_mkwrite, };</code></pre> <p>后续当访问这个vma地址空间时，就会调用相应的操作函数进行处理，比如页错误处理函数会调用<code>ext4_filemap_fault</code>，里面又会调用<code>filemap_fault</code>。</p> <p>如果是设备文件的话，由相应的设备驱动实现mmap方法，在里面建立设备物理内存到vma地址空间的映射。接下来通过一个简单的驱动demo来演示。</p> <p>简单总结一下</p> <pre><code>mmap                        // offset转成页为单位 +-- sys_mmap_pgoff          // 通过fd获取file     +-- vm_mmap_pgoff       // 信号量保护，映射完成后populate         +-- do_mmap_pgoff   // 简单封装             +-- do_mmap     // 映射长度页对齐，prot和flags检查，设置vm_flags，获取映射虚拟地址                 +-- mmap_region      // 地址空间检查，vma_merge，vma分配及初始化                     |-- call_mmap    // 文件映射，简单封装                     |   +-- file-&gt;f_op-&gt;mmap    // 调用实际文件的mmap方法                     |-- shmem_zero_setup       // 匿名共享映射，/dev/zero</code></pre> <h2 id="驱动demo">驱动demo</h2> <p>我们编写了一个简单的misc设备，在驱动加载的时候使用<code>alloc_pages</code>分配设备的物理内存（4页），当然也可以使用kmalloc或vmalloc。然后实现了几个操作方法，其中最主要的就是mmap方法，为了方便测试我们还实现了read、write、llseek等方法。</p> <p>{% note default %}<br /> ps: 驱动及测试程序代码已上传github，<a href="http://www.m6000.cn/wp-content/themes/begin%20lts/inc/go.php?url=https://github.com/catbro666/mmap-driver-demo"  target="_blank" rel="nofollow">catbro666/mmap-driver-demo</a><br /> {% endnote %}</p> <pre><code class="language-c">#include &lt;linux/init.h&gt; #include &lt;linux/module.h&gt; #include &lt;linux/fs.h&gt; #include &lt;linux/mm.h&gt; #include &lt;linux/gfp.h&gt;          // alloc_page #include &lt;linux/miscdevice.h&gt;   // miscdevice misc_xxx #include &lt;linux/uaccess.h&gt;      // copy_from/to_user  #define DEMO_NAME "demo_dev" #define PAGE_ORDER 2 #define MAX_SIZE (PAGE_SIZE &lt;&lt; PAGE_ORDER)  static struct device *mydemodrv_device; static struct page *page = NULL; static char *device_buffer = NULL;  static const struct file_operations demodrv_fops = {     .owner      = THIS_MODULE,     .open       = demodrv_open,     .release    = demodrv_release,     .read       = demodrv_read,     .write      = demodrv_write,     .mmap       = demodev_mmap,     .llseek     = demodev_llseek };  static struct miscdevice mydemodrv_misc_device = {     .minor = MISC_DYNAMIC_MINOR,     .name = DEMO_NAME,     .fops = &amp;demodrv_fops, };  static int __init demo_dev_init(void) {     int ret;      ret = misc_register(&amp;mydemodrv_misc_device);     if (ret) {         printk("failed to register misc device");         return ret;     }      mydemodrv_device = mydemodrv_misc_device.this_device;      printk("succeeded register misc device: %s\n", DEMO_NAME);      page = alloc_pages(GFP_KERNEL, PAGE_ORDER);     if (!page) {         printk("alloc_page failed\n");         return -ENOMEM;     }     device_buffer = page_address(page);     printk("device_buffer physical address: %lx, virtual address: %px\n",            page_to_pfn(page) &lt;&lt; PAGE_SHIFT, device_buffer);      return 0; }   static void __exit demo_dev_exit(void) {     printk("removing device\n");      __free_pages(page, PAGE_ORDER);      misc_deregister(&amp;mydemodrv_misc_device); }  module_init(demo_dev_init); module_exit(demo_dev_exit); MODULE_AUTHOR("catbro666"); MODULE_LICENSE("GPL v2"); MODULE_DESCRIPTION("mmap test module");</code></pre> <p>这里主要看一下mmap方法的实现，核心函数是<code>remap_pfn_range</code>，它用于建立实际物理地址到vma虚拟地址的映射。我们来看下它的参数，第一个是要映射的用户空间vma，第二个是映射起始地址，第三个是内核内存的物理页帧号，第四个是映射区域的大小，第五个是对这个映射的页保护标志。</p> <p>我们用到的大部分参数通过vma获取，如上一节所看到的，外层函数已经做好了vma初始化工作。因为我们是用<code>alloc_pages</code>分配的内存，其物理地址是连续的，所以映射也比较简单。</p> <pre><code class="language-c">static int demodev_mmap(struct file *file, struct vm_area_struct *vma) {     struct mm_struct *mm;     unsigned long size;     unsigned long pfn_start;     void *virt_start;     int ret;      mm = current-&gt;mm;     pfn_start = page_to_pfn(page) + vma-&gt;vm_pgoff;     virt_start = page_address(page) + (vma-&gt;vm_pgoff &lt;&lt; PAGE_SHIFT);      /* 映射大小不超过实际分配的物理内存大小 */     size = min(((1 &lt;&lt; PAGE_ORDER) - vma-&gt;vm_pgoff) &lt;&lt; PAGE_SHIFT,                vma-&gt;vm_end - vma-&gt;vm_start);      printk("phys_start: 0x%lx, offset: 0x%lx, vma_size: 0x%lx, map size:0x%lx\n",            pfn_start &lt;&lt; PAGE_SHIFT, vma-&gt;vm_pgoff &lt;&lt; PAGE_SHIFT,            vma-&gt;vm_end - vma-&gt;vm_start, size);      if (size &lt;= 0) {         printk("%s: offset 0x%lx too large, max size is 0x%lx\n", __func__,                vma-&gt;vm_pgoff &lt;&lt; PAGE_SHIFT, MAX_SIZE);         return -EINVAL;     }      // 外层vm_mmap_pgoff已经用信号量保护了     ret = remap_pfn_range(vma, vma-&gt;vm_start, pfn_start, size, vma-&gt;vm_page_prot);      if (ret) {         printk("remap_pfn_range failed, vm_start: 0x%lx\n", vma-&gt;vm_start);     }     else {         printk("map kernel 0x%px to user 0x%lx, size: 0x%lx\n",                virt_start, vma-&gt;vm_start, size);     }</code></pre> <p>再来看下read方法的实现，主要就是从设备内存中拷贝数据到用户空间的buf中，然后更新文件偏移。write方法也是类似，这里就不再展示。</p> <pre><code class="language-c">static ssize_t demodrv_read(struct file *file, char __user *buf, size_t count, loff_t *ppos) {     int actual_readed;     int max_read;     int need_read;     int ret;     max_read = PAGE_SIZE - *ppos;     need_read = max_read &gt; count ? count : max_read;     if (need_read == 0)         dev_warn(mydemodrv_device, "no space for read");      ret = copy_to_user(buf, device_buffer + *ppos, need_read);     if (ret == need_read)         return -EFAULT;     actual_readed = need_read - ret;     *ppos += actual_readed;      printk("%s actual_readed=%d, pos=%lld\n", __func__, actual_readed, *ppos);     return actual_readed; }</code></pre> <h2 id="测试程序">测试程序</h2> <h3 id="安装驱动">安装驱动</h3> <p>我们首先编译安装驱动，设备节点文件已经自动创建。查看内核日志可以看到已经成功创建了设备，并分配了内存。起始物理地址为0x5b1558000，内核虚拟地址为0xffff8d1ab1558000。</p> <pre><code class="language-bash">$ sudo insmod mydemodev.ko $ ll /dev|grep demo crw-------   1 root root     10,  58 12月 12 23:33 demo_dev $ dmesg | tail -n 2 [110047.799513] succeeded register misc device: demo_dev [110047.799517] device_buffer physical address: 5b1558000, virtual address: ffff8d1ab1558000</code></pre> <h3 id="测试程序1">测试程序1</h3> <p>接下来我们写了几个测试程序来对这个驱动进行测试。首先来看第一个测试程序，我们打开驱动设备文件<code>/dev/demo_dev</code>，然后mmap映射了1页的大小，这里前后分别sleep了5秒，是为了提供观察的时间。然后通过映射的用户空间虚拟地址进行读写测试，验证mmap是否正确映射了。首先通过虚拟地址写，随后用read读取进行比对检查。然后通过write写，随后用虚拟地址读取进行比对检查。</p> <pre><code class="language-c">// test1.c #include &lt;stdio.h&gt;      // printf #include &lt;fcntl.h&gt;      // open #include &lt;unistd.h&gt;     // read, close, getpagesize #include &lt;sys/mman.h&gt;   // mmap #include &lt;string.h&gt;     // memcmp, strlen #include &lt;assert.h&gt;     // assert  #define DEMO_DEV_NAME   "/dev/demo_dev"  int main() {     char buf[64];     int fd;     char *addr = NULL;     int ret;     char *message = "Hello World\n";     char *message2 = "I'm superman\n";      fd = open(DEMO_DEV_NAME, O_RDWR);     if (fd &lt; 0) {         printf("open device %s failed\n", DEMO_DEV_NAME);         return -1;     }          sleep(5);     addr = mmap(NULL, (size_t)getpagesize(), PROT_READ | PROT_WRITE,                 MAP_SHARED | MAP_LOCKED, fd, 0);     sleep(5);          /* 测试映射正确 */     /* 写到mmap映射的虚拟地址中，通过read读取设备文件 */     ret = sprintf(addr, "%s", message);     assert(ret == strlen(message));      ret = read(fd, buf, 64);     assert(ret == 64);     assert(!memcmp(buf, message, strlen(message)));      /* 通过write写入设备文件，修改体现在mmap映射的虚拟地址 */     ret = write(fd, message2, strlen(message2));      assert(ret == strlen(message2));     assert(!memcmp(addr + 64, message2, strlen(message2)));      munmap(addr, (size_t)getpagesize());     close(fd);     return 0; }</code></pre> <p>我们编译运行测试程序，结果如我们预期。从内核日志可以看到映射起始物理地址0x5b1558000，偏移为0，vma大小是1页，映射大小也是1页。将内核空间虚拟地址0xffff8d1ab1558000映射到了用户空间0x7f21c0f58000。</p> <pre><code class="language-bash">$ sudo ./test1 $ dmesg|tail -n 4 [110691.745381] phys_start: 0x5b1558000, offset: 0x0, vma_size: 0x1000, map size:0x1000 [110691.745388] map kernel 0xffff8d1ab1558000 to user 0x7f21c0f58000, size: 0x1000 [110696.745816] demodrv_read actual_readed=64, pos=64 [110696.745822] demodrv_write actual_written=13, pos=77</code></pre> <p>与此同时，我们使用pmap观察mmap前后的进程的地址空间</p> <p>{% fold 点击展开进程地址空间 %}</p> <pre><code class="language-bash">$ sudo pmap -x $(pgrep test1) [sudo] password for ssl: 30830:   ./test1 Address           Kbytes     RSS   Dirty Mode  Mapping 0000557b19475000       4       4       0 r-x-- test1 0000557b19475000       0       0       0 r-x-- test1 0000557b19676000       4       4       4 r---- test1 0000557b19676000       0       0       0 r---- test1 0000557b19677000       4       4       4 rw--- test1 0000557b19677000       0       0       0 rw--- test1 00007f21c0941000    1948     888       0 r-x-- libc-2.27.so 00007f21c0941000       0       0       0 r-x-- libc-2.27.so 00007f21c0b28000    2048       0       0 ----- libc-2.27.so 00007f21c0b28000       0       0       0 ----- libc-2.27.so 00007f21c0d28000      16      16      16 r---- libc-2.27.so 00007f21c0d28000       0       0       0 r---- libc-2.27.so 00007f21c0d2c000       8       8       8 rw--- libc-2.27.so 00007f21c0d2c000       0       0       0 rw--- libc-2.27.so 00007f21c0d2e000      16       8       8 rw---   [ anon ] 00007f21c0d2e000       0       0       0 rw---   [ anon ] 00007f21c0d32000     156     156       0 r-x-- ld-2.27.so 00007f21c0d32000       0       0       0 r-x-- ld-2.27.so 00007f21c0f41000       8       8       8 rw---   [ anon ] 00007f21c0f41000       0       0       0 rw---   [ anon ] 00007f21c0f59000       4       4       4 r---- ld-2.27.so 00007f21c0f59000       0       0       0 r---- ld-2.27.so 00007f21c0f5a000       4       4       4 rw--- ld-2.27.so 00007f21c0f5a000       0       0       0 rw--- ld-2.27.so 00007f21c0f5b000       4       4       4 rw---   [ anon ] 00007f21c0f5b000       0       0       0 rw---   [ anon ] 00007ffdacdf1000     132       8       8 rw---   [ stack ] 00007ffdacdf1000       0       0       0 rw---   [ stack ] 00007ffdacf3c000      12       0       0 r----   [ anon ] 00007ffdacf3c000       0       0       0 r----   [ anon ] 00007ffdacf3f000       4       4       0 r-x--   [ anon ] 00007ffdacf3f000       0       0       0 r-x--   [ anon ] ffffffffff600000       4       0       0 --x--   [ anon ] ffffffffff600000       0       0       0 --x--   [ anon ] ---------------- ------- ------- ------- total kB            4376    1120      68  $ sudo pmap -x $(pgrep test1) 30830:   ./test1 Address           Kbytes     RSS   Dirty Mode  Mapping 0000557b19475000       4       4       0 r-x-- test1 0000557b19475000       0       0       0 r-x-- test1 0000557b19676000       4       4       4 r---- test1 0000557b19676000       0       0       0 r---- test1 0000557b19677000       4       4       4 rw--- test1 0000557b19677000       0       0       0 rw--- test1 00007f21c0941000    1948     888       0 r-x-- libc-2.27.so 00007f21c0941000       0       0       0 r-x-- libc-2.27.so 00007f21c0b28000    2048       0       0 ----- libc-2.27.so 00007f21c0b28000       0       0       0 ----- libc-2.27.so 00007f21c0d28000      16      16      16 r---- libc-2.27.so 00007f21c0d28000       0       0       0 r---- libc-2.27.so 00007f21c0d2c000       8       8       8 rw--- libc-2.27.so 00007f21c0d2c000       0       0       0 rw--- libc-2.27.so 00007f21c0d2e000      16       8       8 rw---   [ anon ] 00007f21c0d2e000       0       0       0 rw---   [ anon ] 00007f21c0d32000     156     156       0 r-x-- ld-2.27.so 00007f21c0d32000       0       0       0 r-x-- ld-2.27.so 00007f21c0f41000       8       8       8 rw---   [ anon ] 00007f21c0f41000       0       0       0 rw---   [ anon ] 00007f21c0f58000       4       0       0 rw-s- demo_dev 00007f21c0f58000       0       0       0 rw-s- demo_dev 00007f21c0f59000       4       4       4 r---- ld-2.27.so 00007f21c0f59000       0       0       0 r---- ld-2.27.so 00007f21c0f5a000       4       4       4 rw--- ld-2.27.so 00007f21c0f5a000       0       0       0 rw--- ld-2.27.so 00007f21c0f5b000       4       4       4 rw---   [ anon ] 00007f21c0f5b000       0       0       0 rw---   [ anon ] 00007ffdacdf1000     132       8       8 rw---   [ stack ] 00007ffdacdf1000       0       0       0 rw---   [ stack ] 00007ffdacf3c000      12       0       0 r----   [ anon ] 00007ffdacf3c000       0       0       0 r----   [ anon ] 00007ffdacf3f000       4       4       0 r-x--   [ anon ] 00007ffdacf3f000       0       0       0 r-x--   [ anon ] ffffffffff600000       4       0       0 --x--   [ anon ] ffffffffff600000       0       0       0 --x--   [ anon ] ---------------- ------- ------- ------- total kB            4380    1120      68</code></pre> <p>{% endfold %}</p> <p>可以看到mmap之后多了一个叫做demo_dev的段，其起始地址就是我们映射的用户空间地址0x7f21c0f58000。</p> <pre><code>00007f21c0f58000       4       0       0 rw-s- demo_dev 00007f21c0f58000       0       0       0 rw-s- demo_dev</code></pre> <h3 id="测试程序2">测试程序2</h3> <p>测试程序2差别不大，打开同一个设备文件，mmap建立相同的映射，然后分别通过read和虚拟地址读取前一个程序写的内容。</p> <pre><code class="language-c">// test.2 int main() {     char buf[64];     int fd;     char *addr = NULL;     int ret;     char *message = "Hello World\n";     char *message2 = "I'm superman\n";      /* 另一进程打开同一设备文件，然后用mmap映射 */     fd = open(DEMO_DEV_NAME, O_RDWR);     if (fd &lt; 0) {         printf("open device %s failed\n", DEMO_DEV_NAME);         return -1;     }     addr = mmap(NULL, (size_t)getpagesize(), PROT_READ | PROT_WRITE,                 MAP_SHARED | MAP_LOCKED, fd, 0);      /* 通过read读取设备文件 */     ret = read(fd, buf, sizeof(buf));      assert(ret == sizeof(buf));     assert(!memcmp(buf, message, strlen(message)));      /* 通过mmap映射的虚拟地址读取 */     assert(!memcmp(addr + sizeof(buf), message2, strlen(message2)));      munmap(addr, (size_t)getpagesize());     close(fd);     return 0; }</code></pre> <p>编译运行，测试结果如我们预期。同一个内核虚拟地址现在映射到了不同的用户空间虚拟地址。通过mmap我们实现了进程间通信。</p> <pre><code class="language-bash">$ sudo ./test2 $ dmesg|tail -n 3 [111333.818374] phys_start: 0x5b1558000, offset: 0x0, vma_size: 0x1000, map size:0x1000 [111333.818378] map kernel 0xffff8d1ab1558000 to user 0x7f015ee94000, size: 0x1000 [111333.818381] demodrv_read actual_readed=64, pos=64</code></pre> <h3 id="测试程序3">测试程序3</h3> <p>这次我们来测试一些特殊情况，映射的大小改成了1个字节，根据前面的代码分析，映射是需要页对齐的，所以预期实际会映射一个页。在一页的范围内是可以正常读写的。然后尝试写到vma映射范围之外，预期会出现段错误。</p> <pre><code class="language-c">int main() {     char buf[64];     int fd;     char *addr = NULL;     off_t offset;     int ret;     char *message = "Hello World\n";     char *message2 = "I'm superman\n";      fd = open(DEMO_DEV_NAME, O_RDWR);     if (fd &lt; 0) {         printf("open device %s failed\n", DEMO_DEV_NAME);         return -1;     }     /* 映射1个字节 */     addr = mmap(NULL, 1, PROT_READ | PROT_WRITE,                 MAP_SHARED | MAP_LOCKED, fd, 0);      /* 写到mmap映射的虚拟地址中，通过read读取设备文件 */     ret =sprintf(addr, "%s", message);     assert(ret == strlen(message));      ret = read(fd, buf, sizeof(buf));     assert(ret == sizeof(buf));     assert(!memcmp(buf, message, strlen(message)));      /* 写到一页的尾部 */     ret = sprintf(addr + getpagesize() - sizeof(buf), "%s", message2);     assert(ret == strlen(message2));      offset = lseek(fd, getpagesize() - sizeof(buf), SEEK_SET);     assert(offset == getpagesize() - sizeof(buf));      ret = read(fd, buf, sizeof(buf));     assert(ret == sizeof(buf));     assert(!memcmp(buf, message2, strlen(message2)));          /* 写到一页之后，超出映射范围 */     printf("expect segment error\n");     ret = sprintf(addr + getpagesize(), "something");     printf("never reach here\n");      munmap(addr, 1);     close(fd);     return 0; }</code></pre> <p>我们编译运行测试，结果如我们预期，实际映射了1页的大小，当尝试超出映射范围写时，出现了段错误（SIGSEGV）。</p> <pre><code class="language-bash">$ sudo ./test3 expect segment error Segmentation fault $ dmesg|tail -n 6 [111762.605089] phys_start: 0x5b1558000, offset: 0x0, vma_size: 0x1000, map size:0x1000 [111762.605093] map kernel 0xffff8d1ab1558000 to user 0x7f96b5d08000, size: 0x1000 [111762.605105] demodrv_read actual_readed=64, pos=64 [111762.605110] demodrv_read actual_readed=64, pos=4096 [111762.605165] test3[31001]: segfault at 7f96b5d09000 ip 0000560c0fd3ad25 sp 00007ffc5a515330 error 7 in test3[560c0fd3a000+2000] [111762.605170] Code: e8 80 fb ff ff 48 8d 3d 1a 02 00 00 e8 14 fb ff ff e8 cf fb ff ff 48 63 d0 48 8b 45 80 48 01 d0 48 bb 73 6f 6d 65 74 68 69 6e &lt;48&gt; 89 18 66 c7 40 08 67 00 c7 85 7c ff ff ff 09 00 00 00 48 8d 3d</code></pre> <h3 id="测试程序4">测试程序4</h3> <p>这次我们又修改了mmap的参数，这次映射了2页的大小，偏移设置为3页。因为我们设备分配的物理内存大小是4页，所以映射的第2页已经超出了实际的设备物理内存。预期映射的第一页可以正常读写，第二页会出现bus错误。</p> <pre><code class="language-c">int main() {     char buf[64];     int fd;     char *addr = NULL;     off_t offset;     int ret;     char *message = "Hello World\n";     char *message2 = "I'm superman\n";      fd = open(DEMO_DEV_NAME, O_RDWR);     if (fd &lt; 0) {         printf("open device %s failed\n", DEMO_DEV_NAME);         return -1;     }     /* 映射2页，offset 3页 */     addr = mmap(NULL, getpagesize() * 2, PROT_READ | PROT_WRITE,                 MAP_SHARED | MAP_LOCKED, fd, getpagesize() * 3);      /* 写到mmap映射的虚拟地址中，通过read读取设备文件 */     ret =sprintf(addr, "%s", message);     assert(ret == strlen(message));      offset = lseek(fd, getpagesize() * 3, SEEK_SET);     ret = read(fd, buf, sizeof(buf));     assert(ret == sizeof(buf));     assert(!memcmp(buf, message, strlen(message)));      /* 写到一页之后，超出实际物理内存范围 */     printf("expect bus error\n");     ret = sprintf(addr + getpagesize(), "something");     printf("never reach here\n");      munmap(addr, getpagesize() * 2);     close(fd);     return 0; }</code></pre> <p>编译运行测试程序，结果如预期。虽然vma的大小为2页，但是实际只映射了1页的物理内存，当尝试写到第二页时出现了bus错误(SIGBUS)。</p> <pre><code class="language-bash">$ sudo ./test4 expect bus error Bus error $ dmesg|tail -n 3 [112105.841706] phys_start: 0x5b155b000, offset: 0x3000, vma_size: 0x2000, map size:0x1000 [112105.841710] map kernel 0xffff8d1ab155b000 to user 0x7fe662ec4000, size: 0x1000 [112105.841723] demodrv_read actual_readed=64, pos=12352</code></pre> <h2 id="参考资料">参考资料</h2> <ul> <li><a href="http://www.m6000.cn/wp-content/themes/begin%20lts/inc/go.php?url=https://developpaper.com/linux-virtual-address-space/"  target="_blank" rel="nofollow">linux-virtual-address-space/</a></li> <li><a href="http://www.m6000.cn/wp-content/themes/begin%20lts/inc/go.php?url=https://www.kernel.org/doc/Documentation/x86/x86_64/mm.txt"  target="_blank" rel="nofollow">virtual memory map</a></li> <li>linux-4.15内核源码</li> </ul> 			                <div class="clearfix"></div>
                <div class="col-md-12 mt-5">
                                        <p>上一个：<a href="/news/article-84786.htm">猫咪打疫苗一般多少钱一次打几针（猫咪打疫苗要打几针要多少钱）</a></p>
                                        <p>下一个：<a href="/news/article-85506.htm">动物防疫站给猫打疫苗贵吗（动物防疫中心可以给猫打疫苗吗）</a></p>
                                    </div>
                                </div>
                <div class="col-md-3">
                    <div class="panel panel-default">
    <div class="panel-heading">
        <h3 class="panel-title">热门文章</h3>
    </div>
    <div class="panel-body">
        <ul class="p-0 x-0" style="list-style: none;margin: 0;padding: 0;">
                        <li class="py-2"><a href="/free-nodes/2025-3-29-today-hysteria-node.htm" title="「3月29日」最高速度20.6M/S，2025年Hysteria每天更新免费机场订阅节点链接">「3月29日」最高速度20.6M/S，2025年Hysteria每天更新免费机场订阅节点链接</a></li>
                        <li class="py-2"><a href="/free-nodes/2025-3-8-hysteria-node-github.htm" title="「3月8日」最高速度21.8M/S，2025年Hysteria每天更新免费机场订阅节点链接">「3月8日」最高速度21.8M/S，2025年Hysteria每天更新免费机场订阅节点链接</a></li>
                        <li class="py-2"><a href="/news/article-75753.htm" title="Druid10 监控">Druid10 监控</a></li>
                        <li class="py-2"><a href="/free-nodes/2025-3-17-hysteria-node-github.htm" title="「3月17日」最高速度20.2M/S，2025年Hysteria每天更新免费机场订阅节点链接">「3月17日」最高速度20.2M/S，2025年Hysteria每天更新免费机场订阅节点链接</a></li>
                        <li class="py-2"><a href="/free-nodes/2025-3-5-hysteria-node-share.htm" title="「3月5日」最高速度19.9M/S，2025年Hysteria每天更新免费机场订阅节点链接">「3月5日」最高速度19.9M/S，2025年Hysteria每天更新免费机场订阅节点链接</a></li>
                        <li class="py-2"><a href="/news/article-75754.htm" title="宠物医院收费价目表2023最新消息（宠物医院收费价目表2023最新消息及图片）">宠物医院收费价目表2023最新消息（宠物医院收费价目表2023最新消息及图片）</a></li>
                        <li class="py-2"><a href="/news/article-73731.htm" title="上海宠物领养网（上海宠物狗领养网站）">上海宠物领养网（上海宠物狗领养网站）</a></li>
                        <li class="py-2"><a href="/news/article-83387.htm" title="动物疫苗有没有毒（动物疫苗打到人身上有事吗）">动物疫苗有没有毒（动物疫苗打到人身上有事吗）</a></li>
                        <li class="py-2"><a href="/news/article-67181.htm" title="24小时宠物医院成都（成都宠物医院电话号码）">24小时宠物医院成都（成都宠物医院电话号码）</a></li>
                        <li class="py-2"><a href="/news/article-79172.htm" title="立德动物医院大良分院（立德动物医院大良分院怎么样）">立德动物医院大良分院（立德动物医院大良分院怎么样）</a></li>
                    </ul>
    </div>
</div>

<div class="panel panel-default">
    <div class="panel-heading">
        <h3 class="panel-title">归纳</h3>
    </div>
    <div class="panel-body">
        <ul class="p-0 x-0" style="list-style: none;margin: 0;padding: 0;">
                        <li class="py-2">
                <h4><span class="badge" style="float: right;">6</span> <a href="/date/2025-04/" title="2025-04 归档">2025-04</a></h4>
            </li>
                        <li class="py-2">
                <h4><span class="badge" style="float: right;">90</span> <a href="/date/2025-03/" title="2025-03 归档">2025-03</a></h4>
            </li>
                    </ul>
    </div>
</div>

                </div>
            </div>
        </div>
    </section>
    <!--================About Area End =================-->
        <!-- ================ start footer Area ================= -->
    <footer class="footer-area">
        <div class="container">
            <div class="footer-bottom row align-items-center text-center text-lg-left no-gutters">
                            <p>
                                <a href="/">首页</a> | 
                                <a href="/free-node/">免费节点</a> | 
                                <a href="/news/">新闻资讯</a> |
                                <a href="/about-us.htm">关于我们</a> |
                                <a href="/disclaimer.htm">免责申明</a> |
                                <a href="/privacy.htm">隐私申明</a> |
                                <a href="/sitemap.xml">网站地图</a>
                            </p>
                <p class="footer-text m-0 col-lg-8 col-md-12">
                    HysteriaWindows免费节点官网 版权所有 Powered by WordPress
                </p>
                <div class="col-lg-4 col-md-12 text-center text-lg-right footer-social">
                    <a href="#"><i class="ti-facebook"></i></a>
                    <a href="#"><i class="ti-twitter-alt"></i></a>
                    <a href="#"><i class="ti-dribbble"></i></a>
                    <a href="#"><i class="ti-linkedin"></i></a>
                </div>
            </div>
        </div>
    </footer>
    <!-- ================ End footer Area ================= -->
    <!-- Optional JavaScript -->
    <!-- jQuery first, then Popper.js, then Bootstrap JS -->
    <script src="/assets/website/js/frontend/hysteriawindows/jquery-3.5.1.min.js"></script>
    <script src="/assets/website/js/frontend/hysteriawindows/popper.js"></script>
    <script src="/assets/website/js/frontend/hysteriawindows/bootstrap.min.js"></script>
    <script src="/assets/website/js/frontend/hysteriawindows/owl-carousel/owl.carousel.min.js"></script>
    <script src="/assets/website/js/frontend/hysteriawindows/jquery.ajaxchimp.min.js"></script>
    <script src="/assets/website/js/frontend/hysteriawindows/waypoints.min.js"></script>
    <script src="/assets/website/js/frontend/hysteriawindows/mail-script.js"></script>
    <script src="/assets/website/js/frontend/hysteriawindows/contact.js"></script>
    <script src="/assets/website/js/frontend/hysteriawindows/jquery.form.js"></script>
    <script src="/assets/website/js/frontend/hysteriawindows/jquery.validate.min.js"></script>
    <script src="/assets/website/js/frontend/hysteriawindows/mail-script.js"></script>
    <script src="/assets/website/js/frontend/hysteriawindows/theme.js"></script>
    <script src="https://www.freeclashnode.com/assets/js/frontend/invite-url.js"></script><script src="/assets/website/js/frontend/G.js"></script>
</body>

</html>